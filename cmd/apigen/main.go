// HO.

package main

import (
	"context"
	"fmt"
	"log"
	"math/rand"
	"strings"
	"time"

	"github.com/docker/docker/pkg/namesgenerator"
	fuzz "github.com/google/gofuzz"
	"github.com/pkg/errors"
	"github.com/spf13/cobra"
	v1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	"k8s.io/apimachinery/pkg/api/apitesting/fuzzer"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/runtime/serializer"
	"k8s.io/cli-runtime/pkg/genericclioptions"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

const (
	optGVCount  = "gv-count"
	optCRDCount = "crd-count"
	version     = "v1alpha1"
	labelPrefix = "apigen"
)

var (
	propTypes   = []string{"object", "integer", "string", "boolean", "number"}
	gvCount     int
	crdCount    int
	groupSuffix string
	propCount   int
	delay       time.Duration
)

func main() {
	var (
		cf *genericclioptions.ConfigFlags
		c  client.Client
	)
	rand.Seed(time.Now().UnixNano())
	rootCmd := &cobra.Command{
		Use:     "apigen <command> [<GV count> <CRD count>]",
		Short:   "Generate/delete API endpoints",
		Example: "apigen generate -g 10 -c 100",
		Args:    cobra.MinimumNArgs(1),
		PersistentPreRunE: func(_ *cobra.Command, _ []string) error {
			restConfig, err := cf.ToRESTConfig()
			if err != nil {
				return errors.Wrap(err, "failed to get rest config")
			}
			scheme := runtime.NewScheme()
			if err := v1.AddToScheme(scheme); err != nil {
				return errors.Wrap(err, "failed to initialize runtime scheme")
			}
			c, err = client.New(restConfig, client.Options{
				Scheme: scheme,
			})
			return errors.Wrap(err, "failed to initialize a new Kubernetes client")
		},
	}
	generateCmd := &cobra.Command{
		Use:   "generate",
		Short: "Generate specified number of GVs and CRDs",
		Long: fmt.Sprintf("Generate specified number of CRDs distributed into specified number of GVs. "+
			`Generated CRDs will have the "%s.<group-suffix>" label on them.`, labelPrefix),
		Args: cobra.MaximumNArgs(0),
		PreRunE: func(_ *cobra.Command, _ []string) error {
			if gvCount > crdCount {
				return errors.Errorf("gv count cannot be greater than CRD count: %s=%d, %s=%d",
					optGVCount, gvCount, optCRDCount, crdCount)
			}
			if crdCount > 0 && gvCount < 1 {
				return errors.New("gv count must be greater than zero")
			}
			return nil
		},
		RunE: func(_ *cobra.Command, _ []string) error {
			return generate(c)
		},
	}
	deleteCmd := &cobra.Command{
		Use:   "delete",
		Short: "Delete CRDs generated by a previous run",
		Long:  fmt.Sprintf(`Delete the CRDs that have the label "%s.<group-suffix>"" on them`, labelPrefix),
		Args:  cobra.MaximumNArgs(0),
		RunE: func(_ *cobra.Command, _ []string) error {
			return deleteCRDs(c, groupSuffix)
		},
	}
	rootCmd.AddCommand(generateCmd, deleteCmd)
	rootCmd.PersistentFlags().StringVar(&groupSuffix, "group-suffix", "ulucinar.github.com", "Group suffix to be appended to the generated group names")
	cf = genericclioptions.NewConfigFlags(true)
	cf.AddFlags(rootCmd.PersistentFlags())

	generateCmd.Flags().IntVarP(&gvCount, optGVCount, "g", 0, "Number of distinct GVs to generate")
	if err := generateCmd.MarkFlagRequired(optGVCount); err != nil {
		panic(err)
	}
	generateCmd.Flags().IntVarP(&crdCount, optCRDCount, "c", 0, "Number of distinct CRDs to generate")
	if err := generateCmd.MarkFlagRequired(optCRDCount); err != nil {
		panic(err)
	}
	generateCmd.Flags().IntVar(&propCount, "property-count", 0, "Number of OpenAPIv3 schema properties per CRD. If 0, randomized between 1 and 100 for each CRD.")
	generateCmd.Flags().DurationVarP(&delay, "delay", "d", 0, "Delay between requests")
	if err := rootCmd.Execute(); err != nil {
		panic(err)
	}
}

func generate(c client.Client) error {
	scheme := runtime.NewScheme()
	codecs := serializer.NewCodecFactory(scheme)
	if err := v1.AddToScheme(scheme); err != nil {
		return errors.Wrap(err, "failed to initialize runtime scheme")
	}

	var propCounter, maxPropCount int
	fuzzerFuncs := fuzzer.MergeFuzzerFuncs(
		func(codecs serializer.CodecFactory) []interface{} {
			return []interface{}{
				func(obj *v1.JSONSchemaProps, c fuzz.Continue) {
					c.Fuzz(&obj.Title)
					obj.Type = "object"

					props := make(map[string]v1.JSONSchemaProps)
					for {
						p := &v1.JSONSchemaProps{}
						c.Fuzz(&p.Title)
						p.Type = propTypes[c.Int()%len(propTypes)]
						if p.Type == "object" && propCounter < maxPropCount {
							c.Fuzz(p)
						}
						props[c.RandString()] = *p
						propCounter++
						if propCounter >= maxPropCount {
							break
						}
					}
					obj.Properties = props
				},
			}
		})
	f := fuzzer.FuzzerFor(fuzzerFuncs, rand.NewSource(rand.Int63()), codecs)

	log.Printf("Generating %d CRD(s) in %d GV(s)", crdCount, gvCount)
	gvs := make([]*schema.GroupVersion, gvCount)
	j := -1
	labelAPIGen := fmt.Sprintf("%s.%s", labelPrefix, groupSuffix)
	for i := 0; i < crdCount; i++ {
		parts := strings.Split(namesgenerator.GetRandomName(0), "_")
		singular := parts[0] + parts[1]
		plural := singular + "s"
		kind := strings.Title(parts[0]) + strings.Title(parts[1])
		j = (j + 1) % gvCount
		if gvs[j] == nil {
			gvs[j] = &schema.GroupVersion{
				Version: version,
			}
			gvs[j].Group = fmt.Sprintf("%s.%s",
				strings.Replace(namesgenerator.GetRandomName(0), "_", ".", 1), groupSuffix)
		}
		props := &v1.JSONSchemaProps{}
		propCounter = 0
		maxPropCount = propCount
		if maxPropCount == 0 {
			maxPropCount = 1 + rand.Int()%100
		}
		f.Fuzz(props)

		crd := &v1.CustomResourceDefinition{
			ObjectMeta: metav1.ObjectMeta{
				Name: fmt.Sprintf("%s.%s", plural, gvs[j].Group),
				Labels: map[string]string{
					labelAPIGen: "",
				},
			},
			Spec: v1.CustomResourceDefinitionSpec{
				Group: gvs[j].Group,
				Names: v1.CustomResourceDefinitionNames{
					Plural:   plural,
					Singular: singular,
					Kind:     kind,
					ListKind: fmt.Sprintf("%sList", kind),
				},
				Scope: v1.ClusterScoped,
				Versions: []v1.CustomResourceDefinitionVersion{
					{
						Name:    gvs[j].Version,
						Served:  true,
						Storage: true,
						Schema: &v1.CustomResourceValidation{
							OpenAPIV3Schema: props,
						},
					},
				},
			},
		}
		gvk := gvs[j].WithKind(kind).String()
		if err := c.Create(context.TODO(), crd); err != nil {
			return errors.Wrapf(err, "failed to generate CRD: %s", gvk)
		}
		log.Printf("Successfully generated CRD: %s", gvk)
		if delay != 0 && i != crdCount-1 {
			log.Printf("Sleeping for %v before next CRD", delay)
			time.Sleep(delay)
		}
	}

	return nil
}

func deleteCRDs(c client.Client, groupSuffix string) error {
	labelAPIGen := fmt.Sprintf("%s.%s", labelPrefix, groupSuffix)
	log.Printf("Deleting all generated CRDs with label %q", labelAPIGen)
	return errors.Wrapf(c.DeleteAllOf(context.TODO(), &v1.CustomResourceDefinition{}, client.HasLabels([]string{labelAPIGen})), "failed to delete CRDS with label %q", labelAPIGen)
}
